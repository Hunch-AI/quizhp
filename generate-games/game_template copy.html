<!doctype html>
<!-- ======================= index.html ======================= -->
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>HTML5 Canvas Game Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ======================= style.css ======================= -->
  <style>
    :root {
      /* Consistent, tweakable theme (override as needed) */
      --bg: #0f1220;
      --panel: #161a2e;
      --ink: #e6eaf2;
      --muted: #a0a6b0;
      --accent: #8ab4f8;
      --good: #3ccb7f;
      --bad: #ff6b6b;
      --border: #23294d;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font: 16px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    canvas {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      image-rendering: pixelated;
      outline: none;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, .35),
        inset 0 0 0 1px rgba(255, 255, 255, .02);
    }

    .caption {
      text-align: center;
      color: var(--muted);
      margin-top: 10px;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Required dimensions -->
    <canvas id="game" width="720" height="540" tabindex="0" aria-label="Game canvas"></canvas>
  </div>
  <div class="caption">Template loaded â€¢ Add your game in <code>script.js</code></div>

  <!-- ======================= core.js ======================= -->
  <script>
    ; (() => {
      // ---- Registration API and start gate ----
      let __hooks = null, __domReady = false, __started = false;

      function tryStart() {
        if (__domReady && __hooks && !__started) {
          const canvas = document.getElementById('game');
          canvas.focus();
          window.engine = makeEngine(canvas, __hooks);
          __started = true;
        }
      }

      // ---- Theme (applied to CSS variables) ----
      const THEME = {
        bg: getCss('--bg'),
        panel: getCss('--panel'),
        ink: getCss('--ink'),
        muted: getCss('--muted'),
        accent: getCss('--accent'),
        good: getCss('--good'),
        bad: getCss('--bad'),
        border: getCss('--border'),
      };
      function getCss(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

      // ---- Placeholder question object (example) ----
      // Use/replace this in your game logic if you build quiz-style games.
      const QUESTION = {
        type: "mcq",
        prompt: "Which planet is known as the Red Planet?",
        choices: [
          { text: "Venus", is_correct: false, explanation: "Similar in size to Earth, not the Red Planet." },
          { text: "Mars", is_correct: true, explanation: "Appears red due to iron oxide dust." },
          { text: "Jupiter", is_correct: false, explanation: "Gas giant; multicolored bands, not red overall." },
          { text: "Mercury", is_correct: false, explanation: "Gray and closest to the Sun." }
        ]
      };

      // ---- Canvas helpers ----
      function setupCanvas(ctx) {
        ctx.imageSmoothingEnabled = false;
        ctx.textBaseline = 'top';
        ctx.font = '16px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
      }
      function clear(ctx, theme) {
        ctx.fillStyle = theme.panel;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      function centeredText(ctx, text, y, size, color) {
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const w = ctx.canvas.width;
        const m = ctx.measureText(text);
        ctx.fillText(text, (w - m.width) / 2, y);
        ctx.font = prev;
      }
      function wrappedCentered(ctx, text, x, y, maxW, size, lh, color) {
        if (!text) return;
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const words = (text + '').split(/\s+/);
        let line = '';
        const lines = [];
        for (const w of words) {
          const test = line ? line + ' ' + w : w;
          if (ctx.measureText(test).width <= maxW) line = test;
          else { lines.push(line); line = w; }
        }
        if (line) lines.push(line);
        let yy = y;
        const step = size * (lh || 1.35);
        for (const L of lines) {
          const mw = ctx.measureText(L).width;
          ctx.fillText(L, x + (maxW - mw) / 2, yy);
          yy += step;
        }
        ctx.font = prev;
      }

      // ---- Standard End Game Screen (required) ----
      // Call engine.end(true|false) to show it.
      function drawEndScreen(ctx, theme, result) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = theme.bg;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        const isCorrect = (result === 'correct' || result === true);
        const title = isCorrect ? 'Correct' : 'Incorrect';
        const color = isCorrect ? theme.good : theme.bad;

        centeredText(ctx, title, H * 0.33, 48, color);
        centeredText(ctx, 'Press R for restart', H * 0.55, 18, theme.ink);
      }

      // ---- Minimal engine loop + hooks ----
      function makeEngine(canvas, hooks) {
        const ctx = canvas.getContext('2d');
        setupCanvas(ctx);

        const engine = {
          canvas, ctx, theme: THEME,
          state: 'playing',    // 'playing' | 'ended'
          result: null,        // 'correct' | 'incorrect'
          question: QUESTION,

          end(ok) {
            this.state = 'ended';
            this.result = ok ? 'correct' : 'incorrect';
          },
          restart() {
            this.state = 'playing';
            this.result = null;
            hooks.init(this);
          }
        };

        let last = performance.now();
        function loop(now) {
          const dt = Math.min(66, now - last) / 1000;
          last = now;

          clear(ctx, THEME);

          if (engine.state === 'ended') {
            drawEndScreen(ctx, THEME, engine.result);
          } else {
            hooks.update(dt, engine);
            hooks.draw(ctx, engine);
          }
          requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'r' || ev.key === 'R') {
            if (engine.state === 'ended') engine.restart();
          } else if (hooks.keydown) {
            hooks.keydown(ev, engine);
          }
        });

        hooks.init(engine);
        requestAnimationFrame(loop);
        return engine;
      }

      function drawTemplateHint(ctx, engine) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        centeredText(ctx, 'Add your game in script.js', H * 0.38, 22, engine.theme.muted);
        wrappedCentered(
          ctx,
          'Define: window.gameInit(engine), window.gameUpdate(dt, engine), window.gameDraw(ctx, engine). ' +
          'Use engine.end(true|false, "optional explanation") to show the standard end screen.',
          40, H * 0.48, W - 80, 14, 1.35, engine.theme.ink
        );
      }

      // Expose a tiny API if needed
      window.GameCore = {
        makeEngine,
        drawEndScreen,
        THEME,
        QUESTION,
        register(h) {
          __hooks = { init() { }, update() { }, draw() { }, keydown: null, ...h };
          tryStart();
        }
      };

      window.addEventListener('DOMContentLoaded', () => {
        __domReady = true;
        tryStart();
      });
    })();
  </script>

  <!-- ======================= script.js (your game goes here) ======================= -->
  <script>
    /*
script.js â€” For you to add code to (do not change any of the code outside of script.js)

HOOKS (prefer this):
  GameCore.register({ init(engine), update(dt, engine), draw(ctx, engine), keydown(ev, engine?) })
Fallback if register isnâ€™t available:
  window.gameInit / gameUpdate / gameDraw / gameKeyDown

ENGINE BASICS:
  engine.canvas (720x540), engine.ctx, engine.theme.{bg,panel,ink,muted,accent,good,bad,border}
  engine.end(true|false) â†’ shows "Correct"/"Incorrect" + "Press R for restart"
  engine.question?.choices -> [{ text, is_correct, explanation }]
  DO NOT render the question prompt or generic instructions â€” only choicesâ€™ text if you need it.

RENDERING / STYLE:
  â€¢ Use integer positions for crisp 8-bit feel; keep fonts small (12â€“20px).
  â€¢ Canvas size is fixed (720x540). Donâ€™t scale via CSS.
  â€¢ Draw with theme colors for consistent look; imageSmoothing is already off.

INPUT & CLEANUP:
  â€¢ Add listeners in init(); store remover in engine._cleanup = () => {...}.
  â€¢ Map clicks/keys as you wish, but keep 'R' for restart.
  â€¢ If using mouse coords, convert clientX/Y â†’ canvas space (account for CSS scale).

QUIZ-LIKE GAMES:
  â€¢ You may display ONLY choices[i].text.
  â€¢ On selection: engine.end(choices[i].is_correct === true). End on any choice.

EMOJIS / SHAPES:
  â€¢ Use emojis (ðŸª™ðŸ’¥) as sprites via fillText, or shapes (rect/arc/lines).
  â€¢ Keep UI minimal; no prompt/instruction text.

SOUND (optional, 1â€“2 short blips):
  â€¢ Create an AudioContext on first user input; play tiny square-wave beeps (low volume).
  â€¢ Example idea: high beep on select, low beep on incorrect. Keep <0.12s.

LOOP RULE:
  â€¢ Put all game updates in update(dt) and visuals in draw(ctx). Avoid setInterval.

â€” Minimal skeleton (comment out/remove when generating) â€”
  // GameCore.register({
  //   init(e){ /* setup state, add listeners; set e._cleanup */
    //   update(dt,e){ /* move/animate using dt */ },
    //   draw(ctx,e){ /* render; only choicesâ€™ text if applicable */ },
    //   keydown(ev,e){ /* handle input; call e.end(true/false) to finish */ }
    // });

    // WRITE YOUR CODE HERE


  </script>
</body>

</html>