<!doctype html>
<!-- ======================= index.html ======================= -->
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>HTML5 Canvas Game Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ======================= style.css ======================= -->
  <style>
    :root {
      /* Consistent, tweakable theme (override as needed) */
      --bg: #0f1220;
      --panel: #161a2e;
      --ink: #e6eaf2;
      --muted: #a0a6b0;
      --accent: #8ab4f8;
      --good: #3ccb7f;
      --bad: #ff6b6b;
      --border: #23294d;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font: 16px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    canvas {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      image-rendering: pixelated;
      outline: none;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, .35),
        inset 0 0 0 1px rgba(255, 255, 255, .02);
    }

    .caption {
      text-align: center;
      color: var(--muted);
      margin-top: 10px;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Required dimensions -->
    <canvas id="game" width="720" height="540" tabindex="0" aria-label="Game canvas"></canvas>
  </div>
  <div class="caption">Slingshot Goal • Drag & release ball to hit True or False paddle</div>

  <!-- ======================= core.js ======================= -->
  <script>
    ; (() => {
      // ---- Registration API and start gate ----
      let __hooks = null, __domReady = false, __started = false;

      function tryStart() {
        if (__domReady && __hooks && !__started) {
          const canvas = document.getElementById('game');
          canvas.focus();
          window.engine = makeEngine(canvas, __hooks);
          __started = true;
        }
      }

      // ---- Theme (applied to CSS variables) ----
      const THEME = {
        bg: getCss('--bg'),
        panel: getCss('--panel'),
        ink: getCss('--ink'),
        muted: getCss('--muted'),
        accent: getCss('--accent'),
        good: getCss('--good'),
        bad: getCss('--bad'),
        border: getCss('--border'),
      };
      function getCss(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

      // ---- Placeholder question object (example) ----
      // Use/replace this in your game logic if you build quiz-style games.
      const QUESTION = {
        type: "true_false",
        prompt: "Lightning never strikes the same place twice.",
        choices: [
          {
            text: "True",
            is_correct: false,
            explanation: "Myth. Lightning frequently strikes the same tall objects multiple times."
          },
          {
            text: "False",
            is_correct: true,
            explanation: "Correct. Landmarks like skyscrapers are struck repeatedly."
          }
        ]
      };

      // ---- Canvas helpers ----
      function setupCanvas(ctx) {
        ctx.imageSmoothingEnabled = false;
        ctx.textBaseline = 'top';
        ctx.font = '16px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
      }
      function clear(ctx, theme) {
        ctx.fillStyle = theme.panel;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      function centeredText(ctx, text, y, size, color) {
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const w = ctx.canvas.width;
        const m = ctx.measureText(text);
        ctx.fillText(text, (w - m.width) / 2, y);
        ctx.font = prev;
      }
      function wrappedCentered(ctx, text, x, y, maxW, size, lh, color) {
        if (!text) return;
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const words = (text + '').split(/\s+/);
        let line = '';
        const lines = [];
        for (const w of words) {
          const test = line ? line + ' ' + w : w;
          if (ctx.measureText(test).width <= maxW) line = test;
          else { lines.push(line); line = w; }
        }
        if (line) lines.push(line);
        let yy = y;
        const step = size * (lh || 1.35);
        for (const L of lines) {
          const mw = ctx.measureText(L).width;
          ctx.fillText(L, x + (maxW - mw) / 2, yy);
          yy += step;
        }
        ctx.font = prev;
      }

      // ---- Standard End Game Screen (required) ----
      // Call engine.end(true|false) to show it.
      function drawEndScreen(ctx, theme, result) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = theme.bg;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        const isCorrect = (result === 'correct' || result === true);
        const title = isCorrect ? 'Correct' : 'Incorrect';
        const color = isCorrect ? theme.good : theme.bad;

        centeredText(ctx, title, H * 0.33, 48, color);
        centeredText(ctx, 'Press R for restart', H * 0.55, 18, theme.ink);
      }

      // ---- Minimal engine loop + hooks ----
      function makeEngine(canvas, hooks) {
        const ctx = canvas.getContext('2d');
        setupCanvas(ctx);

        const engine = {
          canvas, ctx, theme: THEME,
          state: 'playing',    // 'playing' | 'ended'
          result: null,        // 'correct' | 'incorrect'
          question: QUESTION,

          end(ok) {
            this.state = 'ended';
            this.result = ok ? 'correct' : 'incorrect';
          },
          restart() {
            this.state = 'playing';
            this.result = null;
            hooks.init(this);
          }
        };

        let last = performance.now();
        function loop(now) {
          const dt = Math.min(66, now - last) / 1000;
          last = now;

          clear(ctx, THEME);

          if (engine.state === 'ended') {
            drawEndScreen(ctx, THEME, engine.result);
          } else {
            hooks.update(dt, engine);
            hooks.draw(ctx, engine);
          }
          requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'r' || ev.key === 'R') {
            if (engine.state === 'ended') engine.restart();
          } else if (hooks.keydown) {
            hooks.keydown(ev, engine);
          }
        });

        hooks.init(engine);
        requestAnimationFrame(loop);
        return engine;
      }

      function drawTemplateHint(ctx, engine) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        centeredText(ctx, 'Add your game in script.js', H * 0.38, 22, engine.theme.muted);
        wrappedCentered(
          ctx,
          'Define: window.gameInit(engine), window.gameUpdate(dt, engine), window.gameDraw(ctx, engine). ' +
          'Use engine.end(true|false, "optional explanation") to show the standard end screen.',
          40, H * 0.48, W - 80, 14, 1.35, engine.theme.ink
        );
      }

      // Expose a tiny API if needed
      window.GameCore = {
        makeEngine,
        drawEndScreen,
        THEME,
        QUESTION,
        register(h) {
          __hooks = { init() { }, update() { }, draw() { }, keydown: null, ...h };
          tryStart();
        }
      };

      window.addEventListener('DOMContentLoaded', () => {
        __domReady = true;
        tryStart();
      });
    })();
  </script>

  <!-- ======================= script.js (your game goes here) ======================= -->
  <script>
    // Enhanced Slingshot Goal True/False Game
    // Drag & release ball from bottom-center to hit drifting True/False paddles

    GameCore.register({
      init(e) {
        const W = e.canvas.width, H = e.canvas.height;

        // Ensure question matches requested schema
        e.question = {
          type: "true_false",
          prompt: "Lightning never strikes the same place twice.",
          choices: [
            { text: "True", is_correct: false, explanation: "Myth. Lightning can and does strike the same place repeatedly." },
            { text: "False", is_correct: true, explanation: "Correct. Tall structures are often hit many times." }
          ]
        };

        // Map labels to choices by text
        const choices = e.question.choices;
        const choiceByText = Object.fromEntries(choices.map(c => [c.text.toLowerCase(), c]));

        // Game state
        e._state = {
          W, H,
          // Slingshot geometry (bottom-center)
          pivot: { x: Math.round(W / 2), y: H - 100 },
          prongL: { x: Math.round(W / 2 - 24), y: H - 120 },
          prongR: { x: Math.round(W / 2 + 24), y: H - 120 },
          maxPull: 120,
          powerScale: 14.0,  // Launch power
          gravity: 1200,     // px/s^2
          air: 0.999,        // air drag
          bounce: 0.6,       // wall bounce damping

          // Ball
          ball: {
            r: 12,
            x: Math.round(W / 2),
            y: H - 100,
            vx: 0, vy: 0,
            dragging: false,
            launched: false
          },

          // Drifting paddles (True and False)
          paddles: [
            {
              label: "True",
              x: 120, y: 150, w: 100, h: 50,
              vx: 80,   // drift speed (pixels/second)
              choice: choiceByText["true"] || null,
              color: e.theme.good
            },
            {
              label: "False",
              x: 500, y: 250, w: 100, h: 50,
              vx: -120, // different speed and direction
              choice: choiceByText["false"] || null,
              color: e.theme.bad
            }
          ],

          // Input
          pointerId: null,
          pointer: { x: 0, y: 0 },

          // Game timer
          timeSinceLaunch: 0,
          maxRoundTime: 15 // seconds
        };

        // Pointer helpers
        const toCanvas = (ev) => {
          const rect = e.canvas.getBoundingClientRect();
          const sx = e.canvas.width / rect.width;
          const sy = e.canvas.height / rect.height;
          return {
            x: (ev.clientX - rect.left) * sx,
            y: (ev.clientY - rect.top) * sy
          };
        };

        const st = e._state;
        const b = st.ball;

        // Mouse/touch events
        const onDown = (ev) => {
          if (st.pointerId !== null) return;
          st.pointerId = ev.pointerId ?? "mouse";
          const p = toCanvas(ev);
          st.pointer = p;

          // Grab only if near the ball (before launch)
          const dx = p.x - b.x, dy = p.y - b.y;
          const near = Math.hypot(dx, dy) <= b.r + 20;
          if (!b.launched && near) {
            b.dragging = true;
          }
          e.canvas.setPointerCapture?.(ev.pointerId);
        };

        const onMove = (ev) => {
          if (st.pointerId !== (ev.pointerId ?? "mouse")) return;
          const p = toCanvas(ev);
          st.pointer = p;

          if (b.dragging && !b.launched) {
            // Constrain to a circle of radius maxPull around pivot
            const vx = p.x - st.pivot.x;
            const vy = p.y - st.pivot.y;
            const d = Math.hypot(vx, vy);
            if (d > st.maxPull) {
              const k = st.maxPull / (d || 1);
              b.x = st.pivot.x + vx * k;
              b.y = st.pivot.y + vy * k;
            } else {
              b.x = p.x;
              b.y = p.y;
            }
          }
        };

        const onUpOrCancel = (ev) => {
          if (st.pointerId !== (ev.pointerId ?? "mouse")) return;
          // Release shot if dragging
          if (b.dragging && !b.launched) {
            const dx = st.pivot.x - b.x;
            const dy = st.pivot.y - b.y;
            b.vx = dx * st.powerScale;
            b.vy = dy * st.powerScale;
            b.dragging = false;
            b.launched = true;
            st.timeSinceLaunch = 0;
          }
          st.pointerId = null;
          try { e.canvas.releasePointerCapture?.(ev.pointerId); } catch { }
        };

        e.canvas.addEventListener('pointerdown', onDown);
        e.canvas.addEventListener('pointermove', onMove);
        e.canvas.addEventListener('pointerup', onUpOrCancel);
        e.canvas.addEventListener('pointercancel', onUpOrCancel);
        e.canvas.addEventListener('pointerleave', onUpOrCancel);

        e._cleanup = () => {
          e.canvas.removeEventListener('pointerdown', onDown);
          e.canvas.removeEventListener('pointermove', onMove);
          e.canvas.removeEventListener('pointerup', onUpOrCancel);
          e.canvas.removeEventListener('pointercancel', onUpOrCancel);
          e.canvas.removeEventListener('pointerleave', onUpOrCancel);
        };
      },

      update(dt, e) {
        const st = e._state;
        const b = st.ball;
        const { W, H } = st;

        // Update drifting paddles
        for (const paddle of st.paddles) {
          paddle.x += paddle.vx * dt;

          // Bounce paddles off screen edges
          if (paddle.x <= 0) {
            paddle.x = 0;
            paddle.vx = Math.abs(paddle.vx);
          } else if (paddle.x + paddle.w >= W) {
            paddle.x = W - paddle.w;
            paddle.vx = -Math.abs(paddle.vx);
          }
        }

        // Ball physics only after launch
        if (b.launched) {
          st.timeSinceLaunch += dt;

          // Gravity + air drag
          b.vy += st.gravity * dt;
          b.vx *= Math.pow(st.air, Math.max(1, dt * 60));
          b.vy *= Math.pow(st.air, Math.max(1, dt * 60));

          // Integrate position
          b.x += b.vx * dt;
          b.y += b.vy * dt;

          // Wall collisions (circle vs canvas bounds)
          if (b.x - b.r < 0) {
            b.x = b.r;
            b.vx = -b.vx * st.bounce;
          } else if (b.x + b.r > W) {
            b.x = W - b.r;
            b.vx = -b.vx * st.bounce;
          }
          if (b.y - b.r < 0) {
            b.y = b.r;
            b.vy = -b.vy * st.bounce;
          } else if (b.y + b.r > H) {
            // Ball hit the floor - end game as incorrect
            e.end(false);
            return;
          }

          // Paddle collision check
          for (const paddle of st.paddles) {
            if (circleRectHit(b.x, b.y, b.r, paddle.x, paddle.y, paddle.w, paddle.h)) {
              const ok = !!(paddle.choice && paddle.choice.is_correct === true);
              e.end(ok);
              return;
            }
          }

          // Timeout fail-safe
          if (st.timeSinceLaunch > st.maxRoundTime) {
            e.end(false);
          }
        } else {
          // If not launched and not dragging, keep ball at pivot
          if (!b.dragging) {
            b.x = st.pivot.x;
            b.y = st.pivot.y;
          }
        }

        // Helper — circle-rect collision
        function circleRectHit(cx, cy, r, rx, ry, rw, rh) {
          const nx = Math.max(rx, Math.min(cx, rx + rw));
          const ny = Math.max(ry, Math.min(cy, ry + rh));
          const dx = cx - nx, dy = cy - ny;
          return (dx * dx + dy * dy) <= r * r;
        }
      },

      draw(ctx, e) {
        const st = e._state;
        const { W, H } = st;
        const T = e.theme;
        const b = st.ball;

        // Draw goal area indicator (subtle background)
        ctx.strokeStyle = T.border;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(0, 0, W, H - 150);
        ctx.setLineDash([]);

        // Slingshot base
        ctx.fillStyle = T.border;
        ctx.strokeStyle = T.border;
        ctx.lineWidth = 2;
        roundedRect(ctx, st.pivot.x - 16, H - 80, 32, 40, 4);
        ctx.fill();
        ctx.stroke();

        // Slingshot prongs
        ctx.strokeStyle = T.accent;
        ctx.lineWidth = 4;
        line(ctx, st.pivot.x - 4, H - 80, st.prongL.x, st.prongL.y);
        line(ctx, st.pivot.x + 4, H - 80, st.prongR.x, st.prongR.y);

        // Elastic band (when not launched or still dragging)
        if (!b.launched || b.dragging) {
          ctx.strokeStyle = T.muted;
          ctx.lineWidth = 3;
          line(ctx, st.prongL.x, st.prongL.y, Math.round(b.x), Math.round(b.y));
          line(ctx, st.prongR.x, st.prongR.y, Math.round(b.x), Math.round(b.y));
        }

        // Draw drifting paddles
        for (const paddle of st.paddles) {
          // Paddle body with motion trail effect
          ctx.fillStyle = paddle.color + '40'; // Semi-transparent trail
          roundedRect(ctx, paddle.x - 5, paddle.y, paddle.w, paddle.h, 8);
          ctx.fill();

          // Main paddle
          ctx.fillStyle = T.panel;
          ctx.strokeStyle = paddle.color;
          ctx.lineWidth = 3;
          roundedRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 8);
          ctx.fill();
          ctx.stroke();

          // Paddle label (only choice text)
          ctx.fillStyle = paddle.color;
          ctx.font = '18px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
          const text = paddle.label.toUpperCase();
          const tw = ctx.measureText(text).width;
          ctx.fillText(text, Math.round(paddle.x + (paddle.w - tw) / 2), Math.round(paddle.y + paddle.h / 2 - 9));

          // Direction indicator
          const arrowX = paddle.vx > 0 ? paddle.x + paddle.w + 10 : paddle.x - 15;
          const arrowY = paddle.y + paddle.h / 2;
          ctx.fillStyle = paddle.color;
          ctx.font = '12px ui-sans-serif';
          ctx.fillText(paddle.vx > 0 ? '→' : '←', arrowX, arrowY - 6);
        }

        // Ball with glow effect
        ctx.shadowColor = T.accent;
        ctx.shadowBlur = 10;
        ctx.fillStyle = T.accent;
        circle(ctx, Math.round(b.x), Math.round(b.y), b.r);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Ball highlight
        ctx.fillStyle = '#ffffff60';
        circle(ctx, Math.round(b.x - 3), Math.round(b.y - 3), b.r / 3);
        ctx.fill();

        // Aim line while dragging
        if (b.dragging && !b.launched) {
          ctx.strokeStyle = T.muted + '80';
          ctx.lineWidth = 2;
          ctx.setLineDash([3, 3]);
          line(ctx, st.pivot.x, st.pivot.y, Math.round(b.x), Math.round(b.y));

          // Trajectory prediction
          const dx = st.pivot.x - b.x;
          const dy = st.pivot.y - b.y;
          const predX = b.x + dx * 3;
          const predY = b.y + dy * 3;
          ctx.strokeStyle = T.accent + '40';
          line(ctx, Math.round(b.x), Math.round(b.y), Math.round(predX), Math.round(predY));
          ctx.setLineDash([]);
        }

        // Game instruction (top center)
        if (!b.launched) {
          ctx.fillStyle = T.muted;
          ctx.font = '16px ui-sans-serif';
          const instruction = "Drag ball & release to hit the correct paddle";
          const tw = ctx.measureText(instruction).width;
          ctx.fillText(instruction, (W - tw) / 2, 30);
        }

        // Utility drawing functions
        function line(ctx, x1, y1, x2, y2) {
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }

        function circle(ctx, x, y, r) {
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
        }

        function roundedRect(ctx, x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.lineTo(x + w - rr, y);
          ctx.arcTo(x + w, y, x + w, y + rr, rr);
          ctx.lineTo(x + w, y + h - rr);
          ctx.arcTo(x + w, y + h, x + w - rr, y + h, rr);
          ctx.lineTo(x + rr, y + h);
          ctx.arcTo(x, y + h, x, y + h - rr, rr);
          ctx.lineTo(x, y + rr);
          ctx.arcTo(x, y, x + rr, y, rr);
          ctx.closePath();
        }
      },

      keydown(ev, e) {
        // R to restart is handled by engine
      }
    });
  </script>
</body>

</html>