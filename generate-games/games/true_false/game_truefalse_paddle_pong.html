<!doctype html>
<!-- ======================= index.html ======================= -->
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>HTML5 Canvas Game Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ======================= style.css ======================= -->
  <style>
    :root {
      /* Consistent, tweakable theme (override as needed) */
      --bg: #0f1220;
      --panel: #161a2e;
      --ink: #e6eaf2;
      --muted: #a0a6b0;
      --accent: #8ab4f8;
      --good: #3ccb7f;
      --bad: #ff6b6b;
      --border: #23294d;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font: 16px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    canvas {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      image-rendering: pixelated;
      outline: none;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, .35),
        inset 0 0 0 1px rgba(255, 255, 255, .02);
    }

    .caption {
      text-align: center;
      color: var(--muted);
      margin-top: 10px;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Required dimensions -->
    <canvas id="game" width="720" height="540" tabindex="0" aria-label="Game canvas"></canvas>
  </div>
  <div class="caption">Template loaded • Add your game in <code>script.js</code></div>

  <!-- ======================= core.js ======================= -->
  <script>
    ; (() => {
      // ---- Registration API and start gate ----
      let __hooks = null, __domReady = false, __started = false;

      function tryStart() {
        if (__domReady && __hooks && !__started) {
          const canvas = document.getElementById('game');
          canvas.focus();
          window.engine = makeEngine(canvas, __hooks);
          __started = true;
        }
      }

      // ---- Theme (applied to CSS variables) ----
      const THEME = {
        bg: getCss('--bg'),
        panel: getCss('--panel'),
        ink: getCss('--ink'),
        muted: getCss('--muted'),
        accent: getCss('--accent'),
        good: getCss('--good'),
        bad: getCss('--bad'),
        border: getCss('--border'),
      };
      function getCss(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

      // ---- Placeholder question object (example) ----
      // Use/replace this in your game logic if you build quiz-style games.
      
      // MULTIPLE CHOICE EXAMPLE:
      const QUESTION = {
        type: "mcq",
        prompt: "Which planet is known as the Red Planet?",
        choices: [
          { text: "Venus", is_correct: false, explanation: "Similar in size to Earth, not the Red Planet." },
          { text: "Mars", is_correct: true, explanation: "Appears red due to iron oxide dust." },
          { text: "Jupiter", is_correct: false, explanation: "Gas giant; multicolored bands, not red overall." },
          { text: "Mercury", is_correct: false, explanation: "Gray and closest to the Sun." }
        ]
      };

      // TRUE/FALSE EXAMPLE (for games like slingshot goal):
      // const QUESTION = {
      //   type: "true_false",
      //   prompt: "Lightning never strikes the same place twice.",
      //   choices: [
      //     { text: "True", is_correct: false, explanation: "Myth. Lightning frequently strikes the same tall objects multiple times." },
      //     { text: "False", is_correct: true, explanation: "Correct. Landmarks like skyscrapers are struck repeatedly." }
      //   ]
      // };

      // ---- Canvas helpers ----
      function setupCanvas(ctx) {
        ctx.imageSmoothingEnabled = false;
        ctx.textBaseline = 'top';
        ctx.font = '16px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
      }
      function clear(ctx, theme) {
        ctx.fillStyle = theme.panel;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      function centeredText(ctx, text, y, size, color) {
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const w = ctx.canvas.width;
        const m = ctx.measureText(text);
        ctx.fillText(text, (w - m.width) / 2, y);
        ctx.font = prev;
      }
      function wrappedCentered(ctx, text, x, y, maxW, size, lh, color) {
        if (!text) return;
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const words = (text + '').split(/\s+/);
        let line = '';
        const lines = [];
        for (const w of words) {
          const test = line ? line + ' ' + w : w;
          if (ctx.measureText(test).width <= maxW) line = test;
          else { lines.push(line); line = w; }
        }
        if (line) lines.push(line);
        let yy = y;
        const step = size * (lh || 1.35);
        for (const L of lines) {
          const mw = ctx.measureText(L).width;
          ctx.fillText(L, x + (maxW - mw) / 2, yy);
          yy += step;
        }
        ctx.font = prev;
      }

      // ---- Standard End Game Screen (required) ----
      // Call engine.end(true|false) to show it.
      function drawEndScreen(ctx, theme, result) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = theme.bg;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        const isCorrect = (result === 'correct' || result === true);
        const title = isCorrect ? 'Correct' : 'Incorrect';
        const color = isCorrect ? theme.good : theme.bad;

        centeredText(ctx, title, H * 0.33, 48, color);
        centeredText(ctx, 'Press R for restart', H * 0.55, 18, theme.ink);
      }

      // ---- Minimal engine loop + hooks ----
      function makeEngine(canvas, hooks) {
        const ctx = canvas.getContext('2d');
        setupCanvas(ctx);

        const engine = {
          canvas, ctx, theme: THEME,
          state: 'playing',    // 'playing' | 'ended'
          result: null,        // 'correct' | 'incorrect'
          question: QUESTION,

          end(ok) {
            this.state = 'ended';
            this.result = ok ? 'correct' : 'incorrect';
          },
          restart() {
            this.state = 'playing';
            this.result = null;
            hooks.init(this);
          }
        };

        let last = performance.now();
        function loop(now) {
          const dt = Math.min(66, now - last) / 1000;
          last = now;

          clear(ctx, THEME);

          if (engine.state === 'ended') {
            drawEndScreen(ctx, THEME, engine.result);
          } else {
            hooks.update(dt, engine);
            hooks.draw(ctx, engine);
          }
          requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'r' || ev.key === 'R') {
            if (engine.state === 'ended') engine.restart();
          } else if (hooks.keydown) {
            hooks.keydown(ev, engine);
          }
        });

        hooks.init(engine);
        requestAnimationFrame(loop);
        return engine;
      }

      function drawTemplateHint(ctx, engine) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        centeredText(ctx, 'Add your game in script.js', H * 0.38, 22, engine.theme.muted);
        wrappedCentered(
          ctx,
          'Define: window.gameInit(engine), window.gameUpdate(dt, engine), window.gameDraw(ctx, engine). ' +
          'Use engine.end(true|false, "optional explanation") to show the standard end screen.',
          40, H * 0.48, W - 80, 14, 1.35, engine.theme.ink
        );
      }

      // Expose a tiny API if needed
      window.GameCore = {
        makeEngine,
        drawEndScreen,
        THEME,
        QUESTION,
        register(h) {
          __hooks = { init() { }, update() { }, draw() { }, keydown: null, ...h };
          tryStart();
        }
      };

      window.addEventListener('DOMContentLoaded', () => {
        __domReady = true;
        tryStart();
      });
    })();
  </script>

  <!-- ======================= script.js (your game goes here) ======================= -->
  <script>
    /*
script.js — For you to add code to (do not change any of the code outside of script.js)

HOOKS (prefer this):
  GameCore.register({ init(engine), update(dt, engine), draw(ctx, engine), keydown(ev, engine?) })
Fallback if register isn’t available:
  window.gameInit / gameUpdate / gameDraw / gameKeyDown

ENGINE BASICS:
  engine.canvas (720x540), engine.ctx, engine.theme.{bg,panel,ink,muted,accent,good,bad,border}
  engine.end(true|false) → shows "Correct"/"Incorrect" + "Press R for restart"
  engine.question?.choices -> [{ text, is_correct, explanation }]
  DO NOT render the question prompt or generic instructions — only choices’ text if you need it.

RENDERING / STYLE:
  • Use integer positions for crisp 8-bit feel; keep fonts small (12–20px).
  • Canvas size is fixed (720x540). Don’t scale via CSS.
  • Draw with theme colors for consistent look; imageSmoothing is already off.

INPUT & CLEANUP:
  • Add listeners in init(); store remover in engine._cleanup = () => {...}.
  • Map clicks/keys as you wish, but keep 'R' for restart.
  • If using mouse coords, convert clientX/Y → canvas space (account for CSS scale).

QUIZ-LIKE GAMES:
  • You may display ONLY choices[i].text.
  • On selection: engine.end(choices[i].is_correct === true). End on any choice.
  
TRUE/FALSE GAMES:
  • Use type: "true_false" in question object.
  • Always have exactly 2 choices: "True" and "False".
  • Map choices by text: const choiceByText = Object.fromEntries(choices.map(c => [c.text.toLowerCase(), c]));
  • Access via choiceByText["true"] or choiceByText["false"] for game logic.
  • Example: slingshot games can have drifting paddles labeled "True"/"False".

EMOJIS / SHAPES:
  • Use emojis (🪙💥) as sprites via fillText, or shapes (rect/arc/lines).
  • Keep UI minimal; no prompt/instruction text.

SOUND (optional, 1–2 short blips):
  • Create an AudioContext on first user input; play tiny square-wave beeps (low volume).
  • Example idea: high beep on select, low beep on incorrect. Keep <0.12s.

LOOP RULE:
  • Put all game updates in update(dt) and visuals in draw(ctx). Avoid setInterval.

— Minimal skeleton (comment out/remove when generating) —
  // GameCore.register({
  //   init(e){ /* setup state, add listeners; set e._cleanup */
    //   update(dt,e){ /* move/animate using dt */ },
    //   draw(ctx,e){ /* render; only choices’ text if applicable */ },
    //   keydown(ev,e){ /* handle input; call e.end(true/false) to finish */ }
    // });

    // Paddle Pong true/false game
    GameCore.register({
      init(e) {
        const W = e.canvas.width, H = e.canvas.height;
        const choices = e.question?.choices || [
          { text: "True", is_correct: true },
          { text: "False", is_correct: false }
        ];
        e.state = {
          paddle: { x: W / 2 - 40, y: H - 30, w: 80, h: 10 },
          ball: {
            x: W / 2,
            y: H - 40,
            vx: 120 * (Math.random() < 0.5 ? -1 : 1),
            vy: -150
          },
          choiceByText: Object.fromEntries(choices.map(c => [c.text.toLowerCase(), c]))
        };
      },

      update(dt, e) {
        const { paddle, ball, choiceByText } = e.state;
        const W = e.canvas.width, H = e.canvas.height;

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        if (ball.x < 0 || ball.x > W) {
          ball.vx *= -1;
          ball.x = Math.max(0, Math.min(W, ball.x));
        }

        if (ball.y < 0) {
          const c = ball.x < W / 2 ? choiceByText.true : choiceByText.false;
          e.end(c.is_correct);
        }

        if (ball.y > H) {
          // reset from bottom
          ball.x = W / 2;
          ball.y = H - 40;
          ball.vx = 120 * (Math.random() < 0.5 ? -1 : 1);
          ball.vy = -150;
        }

        // paddle collision
        if (ball.y > paddle.y - 8 && ball.y < paddle.y &&
          ball.x > paddle.x && ball.x < paddle.x + paddle.w && ball.vy > 0) {
          ball.vy = -Math.abs(ball.vy);
          ball.vx += (ball.x - (paddle.x + paddle.w / 2)) * 4;
        }
      },

      draw(ctx, e) {
        const { paddle, ball } = e.state;
        const W = e.canvas.width;
        ctx.fillStyle = e.theme.ink;
        ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = e.theme.good;
        ctx.fillText("True", 20, 20);
        ctx.fillStyle = e.theme.bad;
        ctx.fillText("False", W - 60, 20);
      },

      keydown(ev, e) {
        const { paddle } = e.state;
        if (ev.key === 'ArrowLeft') {
          paddle.x = Math.max(0, paddle.x - 20);
        } else if (ev.key === 'ArrowRight') {
          const W = e.canvas.width;
          paddle.x = Math.min(W - paddle.w, paddle.x + 20);
        }
      }
    });


  </script>
</body>

</html>