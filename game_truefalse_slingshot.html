<!doctype html>
<!-- ======================= index.html ======================= -->
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>HTML5 Canvas Game Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ======================= style.css ======================= -->
  <style>
    :root {
      /* Consistent, tweakable theme (override as needed) */
      --bg: #0f1220;
      --panel: #161a2e;
      --ink: #e6eaf2;
      --muted: #a0a6b0;
      --accent: #8ab4f8;
      --good: #3ccb7f;
      --bad: #ff6b6b;
      --border: #23294d;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font: 16px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    canvas {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      image-rendering: pixelated;
      outline: none;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, .35),
        inset 0 0 0 1px rgba(255, 255, 255, .02);
    }

    .caption {
      text-align: center;
      color: var(--muted);
      margin-top: 10px;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Required dimensions -->
    <canvas id="game" width="720" height="540" tabindex="0" aria-label="Game canvas"></canvas>
  </div>
  <div class="caption">Template loaded â€¢ Add your game in <code>script.js</code></div>

  <!-- ======================= core.js ======================= -->
  <script>
    ; (() => {
      // ---- Registration API and start gate ----
      let __hooks = null, __domReady = false, __started = false;

      function tryStart() {
        if (__domReady && __hooks && !__started) {
          const canvas = document.getElementById('game');
          canvas.focus();
          window.engine = makeEngine(canvas, __hooks);
          __started = true;
        }
      }

      // ---- Theme (applied to CSS variables) ----
      const THEME = {
        bg: getCss('--bg'),
        panel: getCss('--panel'),
        ink: getCss('--ink'),
        muted: getCss('--muted'),
        accent: getCss('--accent'),
        good: getCss('--good'),
        bad: getCss('--bad'),
        border: getCss('--border'),
      };
      function getCss(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

      // ---- Replace the QUESTION in core.js with this ----
      const QUESTION = {
        type: "true_false",
        prompt: "Lightning never strikes the same place twice.",
        choices: [
          {
            text: "True",
            is_correct: false,
            explanation: "Myth. Lightning frequently strikes the same tall objects multiple times."
          },
          {
            text: "False",
            is_correct: true,
            explanation: "Correct. Landmarks like skyscrapers are struck repeatedly."
          }
        ]
      };


      // ---- Canvas helpers ----
      function setupCanvas(ctx) {
        ctx.imageSmoothingEnabled = false;
        ctx.textBaseline = 'top';
        ctx.font = '16px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
      }
      function clear(ctx, theme) {
        ctx.fillStyle = theme.panel;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      function centeredText(ctx, text, y, size, color) {
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const w = ctx.canvas.width;
        const m = ctx.measureText(text);
        ctx.fillText(text, (w - m.width) / 2, y);
        ctx.font = prev;
      }
      function wrappedCentered(ctx, text, x, y, maxW, size, lh, color) {
        if (!text) return;
        const prev = ctx.font;
        ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.fillStyle = color;
        const words = (text + '').split(/\s+/);
        let line = '';
        const lines = [];
        for (const w of words) {
          const test = line ? line + ' ' + w : w;
          if (ctx.measureText(test).width <= maxW) line = test;
          else { lines.push(line); line = w; }
        }
        if (line) lines.push(line);
        let yy = y;
        const step = size * (lh || 1.35);
        for (const L of lines) {
          const mw = ctx.measureText(L).width;
          ctx.fillText(L, x + (maxW - mw) / 2, yy);
          yy += step;
        }
        ctx.font = prev;
      }

      // ---- Standard End Game Screen (required) ----
      // Call engine.end(true|false) to show it.
      function drawEndScreen(ctx, theme, result) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = theme.bg;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        const isCorrect = (result === 'correct' || result === true);
        const title = isCorrect ? 'Correct' : 'Incorrect';
        const color = isCorrect ? theme.good : theme.bad;

        centeredText(ctx, title, H * 0.33, 48, color);
        centeredText(ctx, 'Press R for restart', H * 0.55, 18, theme.ink);
      }

      // ---- Minimal engine loop + hooks ----
      function makeEngine(canvas, hooks) {
        const ctx = canvas.getContext('2d');
        setupCanvas(ctx);

        const engine = {
          canvas, ctx, theme: THEME,
          state: 'playing',    // 'playing' | 'ended'
          result: null,        // 'correct' | 'incorrect'
          question: QUESTION,

          end(ok) {
            this.state = 'ended';
            this.result = ok ? 'correct' : 'incorrect';
          },
          restart() {
            this.state = 'playing';
            this.result = null;
            hooks.init(this);
          }
        };

        let last = performance.now();
        function loop(now) {
          const dt = Math.min(66, now - last) / 1000;
          last = now;

          clear(ctx, THEME);

          if (engine.state === 'ended') {
            drawEndScreen(ctx, THEME, engine.result);
          } else {
            hooks.update(dt, engine);
            hooks.draw(ctx, engine);
          }
          requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'r' || ev.key === 'R') {
            if (engine.state === 'ended') engine.restart();
          } else if (hooks.keydown) {
            hooks.keydown(ev, engine);
          }
        });

        hooks.init(engine);
        requestAnimationFrame(loop);
        return engine;
      }

      function drawTemplateHint(ctx, engine) {
        const W = ctx.canvas.width, H = ctx.canvas.height;
        centeredText(ctx, 'Add your game in script.js', H * 0.38, 22, engine.theme.muted);
        wrappedCentered(
          ctx,
          'Define: window.gameInit(engine), window.gameUpdate(dt, engine), window.gameDraw(ctx, engine). ' +
          'Use engine.end(true|false, "optional explanation") to show the standard end screen.',
          40, H * 0.48, W - 80, 14, 1.35, engine.theme.ink
        );
      }

      // Expose a tiny API if needed
      window.GameCore = {
        makeEngine,
        drawEndScreen,
        THEME,
        QUESTION,
        register(h) {
          __hooks = { init() { }, update() { }, draw() { }, keydown: null, ...h };
          tryStart();
        }
      };

      window.addEventListener('DOMContentLoaded', () => {
        __domReady = true;
        tryStart();
      });
    })();
  </script>

  <!-- ======================= script.js (your game goes here) ======================= -->
  <script>
    /*
script.js â€” For you to add code to (do not change any of the code outside of script.js)

HOOKS (prefer this):
  GameCore.register({ init(engine), update(dt, engine), draw(ctx, engine), keydown(ev, engine?) })
Fallback if register isnâ€™t available:
  window.gameInit / gameUpdate / gameDraw / gameKeyDown

ENGINE BASICS:
  engine.canvas (720x540), engine.ctx, engine.theme.{bg,panel,ink,muted,accent,good,bad,border}
  engine.end(true|false) â†’ shows "Correct"/"Incorrect" + "Press R for restart"
  engine.question?.choices -> [{ text, is_correct, explanation }]
  DO NOT render the question prompt or generic instructions â€” only choicesâ€™ text if you need it.

RENDERING / STYLE:
  â€¢ Use integer positions for crisp 8-bit feel; keep fonts small (12â€“20px).
  â€¢ Canvas size is fixed (720x540). Donâ€™t scale via CSS.
  â€¢ Draw with theme colors for consistent look; imageSmoothing is already off.

INPUT & CLEANUP:
  â€¢ Add listeners in init(); store remover in engine._cleanup = () => {...}.
  â€¢ Map clicks/keys as you wish, but keep 'R' for restart.
  â€¢ If using mouse coords, convert clientX/Y â†’ canvas space (account for CSS scale).

QUIZ-LIKE GAMES:
  â€¢ You may display ONLY choices[i].text.
  â€¢ On selection: engine.end(choices[i].is_correct === true). End on any choice.

EMOJIS / SHAPES:
  â€¢ Use emojis (ðŸª™ðŸ’¥) as sprites via fillText, or shapes (rect/arc/lines).
  â€¢ Keep UI minimal; no prompt/instruction text.

SOUND (optional, 1â€“2 short blips):
  â€¢ Create an AudioContext on first user input; play tiny square-wave beeps (low volume).
  â€¢ Example idea: high beep on select, low beep on incorrect. Keep <0.12s.

LOOP RULE:
  â€¢ Put all game updates in update(dt) and visuals in draw(ctx). Avoid setInterval.

â€” Minimal skeleton (comment out/remove when generating) â€”
  // GameCore.register({
  //   init(e){ /* setup state, add listeners; set e._cleanup */
    //   update(dt,e){ /* move/animate using dt */ },
    //   draw(ctx,e){ /* render; only choicesâ€™ text if applicable */ },
    //   keydown(ev,e){ /* handle input; call e.end(true/false) to finish */ }
    // });

    // WRITE YOUR CODE HERE
    // Slingshot True/False â€” drag the ball from the bottom-center slingshot and release to hit "True" or "False".
    // Only renders choice text on the targets (as required).

    GameCore.register({
      init(e) {
        const W = e.canvas.width, H = e.canvas.height;

        // Ensure question matches requested schema without editing core.js (safe override)
        e.question = {
          type: "true_false",
          prompt: "Lightning never strikes the same place twice.",
          choices: [
            { text: "True", is_correct: false, explanation: "Myth. Lightning can and does strike the same place repeatedly." },
            { text: "False", is_correct: true, explanation: "Correct. Tall structures are often hit many times." }
          ]
        };

        // Map labels to choices by text
        const choices = e.question.choices;
        const choiceByText = Object.fromEntries(choices.map(c => [c.text.toLowerCase(), c]));

        // World / slingshot state
        e._state = {
          W, H,
          // Slingshot geometry (moved higher up)
          pivot: { x: Math.round(W / 2), y: H - 140 },
          prongL: { x: Math.round(W / 2 - 24), y: H - 160 },
          prongR: { x: Math.round(W / 2 + 24), y: H - 160 },
          maxPull: 120,
          powerScale: 12.0,  // Further increased for higher shots
          gravity: 1800,     // px/s^2
          air: 0.998,        // air drag
          bounce: 0.55,      // wall bounce damping

          // Ball
          ball: {
            r: 14,
            x: Math.round(W / 2),
            y: H - 140,
            vx: 0, vy: 0,
            dragging: false,
            launched: false
          },

          // Targets (True on left, False on right)
          targets: [
            { label: "True", x: Math.round(W * 0.25 - 60), y: 120, w: 120, h: 60, choice: choiceByText["true"] || null },
            { label: "False", x: Math.round(W * 0.75 - 60), y: 120, w: 120, h: 60, choice: choiceByText["false"] || null }
          ],

          // Input
          pointerId: null,
          pointer: { x: 0, y: 0 },

          // Lifespan cap in case player misses forever
          timeSinceLaunch: 0,
          maxRoundTime: 10 // seconds
        };

        // Pointer helpers
        const toCanvas = (ev) => {
          const rect = e.canvas.getBoundingClientRect();
          const sx = e.canvas.width / rect.width;
          const sy = e.canvas.height / rect.height;
          return {
            x: (ev.clientX - rect.left) * sx,
            y: (ev.clientY - rect.top) * sy
          };
        };

        const st = e._state;
        const b = st.ball;

        // Events
        const onDown = (ev) => {
          if (st.pointerId !== null) return;
          st.pointerId = ev.pointerId ?? "mouse";
          const p = toCanvas(ev);
          st.pointer = p;

          // Grab only if near the ball (before launch)
          const dx = p.x - b.x, dy = p.y - b.y;
          const near = Math.hypot(dx, dy) <= b.r + 16;
          if (!b.launched && near) {
            b.dragging = true;
          }
          e.canvas.setPointerCapture?.(ev.pointerId);
        };

        const onMove = (ev) => {
          if (st.pointerId !== (ev.pointerId ?? "mouse")) return;
          const p = toCanvas(ev);
          st.pointer = p;

          if (b.dragging && !b.launched) {
            // Constrain to a circle of radius maxPull around pivot
            const vx = p.x - st.pivot.x;
            const vy = p.y - st.pivot.y;
            const d = Math.hypot(vx, vy);
            if (d > st.maxPull) {
              const k = st.maxPull / (d || 1);
              b.x = st.pivot.x + vx * k;
              b.y = st.pivot.y + vy * k;
            } else {
              b.x = p.x; b.y = p.y;
            }
          }
        };

        const onUpOrCancel = (ev) => {
          if (st.pointerId !== (ev.pointerId ?? "mouse")) return;
          // Release shot if dragging
          if (b.dragging && !b.launched) {
            const dx = st.pivot.x - b.x;
            const dy = st.pivot.y - b.y;
            b.vx = dx * st.powerScale;
            b.vy = dy * st.powerScale;
            b.dragging = false;
            b.launched = true;
            st.timeSinceLaunch = 0;
          }
          st.pointerId = null;
          try { e.canvas.releasePointerCapture?.(ev.pointerId); } catch { }
        };

        e.canvas.addEventListener('pointerdown', onDown);
        e.canvas.addEventListener('pointermove', onMove);
        e.canvas.addEventListener('pointerup', onUpOrCancel);
        e.canvas.addEventListener('pointercancel', onUpOrCancel);
        e.canvas.addEventListener('pointerleave', onUpOrCancel);

        e._cleanup = () => {
          e.canvas.removeEventListener('pointerdown', onDown);
          e.canvas.removeEventListener('pointermove', onMove);
          e.canvas.removeEventListener('pointerup', onUpOrCancel);
          e.canvas.removeEventListener('pointercancel', onUpOrCancel);
          e.canvas.removeEventListener('pointerleave', onUpOrCancel);
        };
      },

      update(dt, e) {
        const st = e._state;
        const b = st.ball;
        const { W, H } = st;

        // Physics only after launch
        if (b.launched) {
          st.timeSinceLaunch += dt;

          // Gravity + simple drag
          b.vy += st.gravity * dt;
          b.vx *= Math.pow(st.air, Math.max(1, dt * 60));
          b.vy *= Math.pow(st.air, Math.max(1, dt * 60));

          // Integrate
          b.x += b.vx * dt;
          b.y += b.vy * dt;

          // Wall collisions (circle vs canvas bounds)
          if (b.x - b.r < 0) {
            b.x = b.r; b.vx = -b.vx * st.bounce;
          } else if (b.x + b.r > W) {
            b.x = W - b.r; b.vx = -b.vx * st.bounce;
          }
          if (b.y - b.r < 0) {
            b.y = b.r; b.vy = -b.vy * st.bounce;
          } else if (b.y + b.r > H) {
            // Ball hit the floor - end game as incorrect
            e.end(false);
            return;
          }

          // Target collision check
          for (const t of st.targets) {
            if (circleRectHit(b.x, b.y, b.r, t.x, t.y, t.w, t.h)) {
              const ok = !!(t.choice && t.choice.is_correct === true);
              e.end(ok);
              return;
            }
          }

          // Fail-safe end (timeout)
          if (st.timeSinceLaunch > st.maxRoundTime) {
            e.end(false);
          }
        } else {
          // If not launched and not dragging, keep ball at pivot (nestled)
          if (!b.dragging) {
            b.x = st.pivot.x;
            b.y = st.pivot.y;
          }
        }

        // Helper â€” circle-rect collision
        function circleRectHit(cx, cy, r, rx, ry, rw, rh) {
          const nx = Math.max(rx, Math.min(cx, rx + rw));
          const ny = Math.max(ry, Math.min(cy, ry + rh));
          const dx = cx - nx, dy = cy - ny;
          return (dx * dx + dy * dy) <= r * r;
        }
      },

      draw(ctx, e) {
        const st = e._state;
        const { W, H } = st;
        const T = e.theme;
        const b = st.ball;

        // Ground / base
        // Slingshot base
        ctx.strokeStyle = T.border;
        ctx.lineWidth = 2;
        roundedRect(ctx, st.pivot.x - 20, H - 120, 40, 60, 6); ctx.stroke();

        // Fork (prongs)
        ctx.strokeStyle = T.accent;
        ctx.lineWidth = 3;
        line(ctx, st.pivot.x - 4, H - 120, st.prongL.x, st.prongL.y);
        line(ctx, st.pivot.x + 4, H - 120, st.prongR.x, st.prongR.y);

        // Elastic band
        if (!b.launched || b.dragging) {
          ctx.strokeStyle = T.muted;
          ctx.lineWidth = 3;
          line(ctx, st.prongL.x, st.prongL.y, Math.round(b.x), Math.round(b.y));
          line(ctx, st.prongR.x, st.prongR.y, Math.round(b.x), Math.round(b.y));
        }

        // Targets: True (left), False (right)
        for (const t of st.targets) {
          const isTrue = t.label.toLowerCase() === "true";
          // Border color hint (subtle): good for True, bad for False
          ctx.lineWidth = 2;
          ctx.strokeStyle = isTrue ? T.good : T.bad;
          ctx.fillStyle = e.theme.panel;
          roundedRect(ctx, t.x, t.y, t.w, t.h, 10);
          ctx.fill();
          ctx.stroke();

          // Label (only choice text)
          ctx.fillStyle = T.ink;
          ctx.font = '18px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif';
          const text = t.label.toUpperCase();
          const tw = ctx.measureText(text).width;
          ctx.fillText(text, Math.round(t.x + (t.w - tw) / 2), Math.round(t.y + t.h / 2 - 10));
        }

        // Ball
        ctx.fillStyle = T.accent;
        circle(ctx, Math.round(b.x), Math.round(b.y), b.r);
        ctx.fill();

        // Optional: a faint aim line while dragging
        if (b.dragging && !b.launched) {
          ctx.strokeStyle = T.muted;
          ctx.lineWidth = 1;
          line(ctx, st.pivot.x, st.pivot.y, Math.round(b.x), Math.round(b.y));
        }

        // Utility drawing functions
        function line(ctx, x1, y1, x2, y2) {
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
        function circle(ctx, x, y, r) {
          ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); /* no stroke by default */
        }
        function roundedRect(ctx, x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.lineTo(x + w - rr, y);
          ctx.arcTo(x + w, y, x + w, y + rr, rr);
          ctx.lineTo(x + w, y + h - rr);
          ctx.arcTo(x + w, y + h, x + w - rr, y + h, rr);
          ctx.lineTo(x + rr, y + h);
          ctx.arcTo(x, y + h, x, y + h - rr, rr);
          ctx.lineTo(x, y + rr);
          ctx.arcTo(x, y, x + rr, y, rr);
          ctx.closePath();
        }
      },

      keydown(ev, e) {
        // Nothing special; R to restart is handled by engine
      }
    });





  </script>
</body>

</html>